#!/bin/sh
set -eu

# Re-exec outside of apparmor confinement
if [ -d /sys/kernel/security/apparmor ] && [ "$(cat /proc/self/attr/current)" != "unconfined" ]; then
    exec aa-exec -p unconfined -- "$0" "$@"
fi

echo "=> Preparing the system"
export SNAP_CURRENT="$(realpath "${SNAP}/..")/current"
export LXD_DIR="${SNAP_COMMON}/lxd/"
export LXD_LXC_TEMPLATE_CONFIG="${SNAP_CURRENT}/lxc/config/"
export HOME="/tmp/"

# Load our configuration
echo "==> Loading snap configuration"
. "${SNAP_COMMON}/config"

# Fix modprobe
echo "==> Setting up modprobe wrapper"
mount -o bind "${SNAP}/bin/modprobe" "/sbin/modprobe"

# Setup a functional /run
echo "==> Preparing a clean copy of /run"
umount -l /run >/dev/null 2>&1 || true
mount -t tmpfs tmpfs /run -o mode=0755,nosuid,nodev
for entry in NetworkManager resolvconf snapd snapd.socket snapd-snap.socket systemd; do
    [ -e "/var/lib/snapd/hostfs/run/${entry}" ] || continue
    ln -s "/var/lib/snapd/hostfs/run/${entry}" "/run/${entry}"
done

# Setup a functional /etc
echo "==> Preparing a clean copy of /etc"

## Unmount and replace with an empty tmpfs
umount -l /etc >/dev/null 2>&1 || true
mount -t tmpfs tmpfs /etc -o mode=0755

## Pass the bits we need from the host
for entry in hostname hosts nsswitch.conf os-release passwd group resolv.conf writable; do
    [ -e "/var/lib/snapd/hostfs/etc/${entry}" ] || continue
    ln -s "/var/lib/snapd/hostfs/etc/${entry}" "/etc/${entry}"
done

## And the bits we need from the core snap
for entry in alternatives apparmor apparmor.d ssl vim; do
    [ -e "/snap/core/current/etc/${entry}" ] || continue
    ln -s "/snap/core/current/etc/${entry}" "/etc/${entry}"
done

# FIXME: Setup bash completion on the host
#        This should be handled by snapd directly (LP: #1590767)
if [ -w "/var/lib/snapd/hostfs/etc/bash_completion.d/" ]; then
    if [ ! -e "/var/lib/snapd/hostfs/etc/bash_completion.d/lxc" ]; then
        echo "==> Setting up bash completion"
        rm -f /var/lib/snapd/hostfs/etc/bash_completion.d/lxc
        ln -s "${SNAP_CURRENT}/etc/bash_completion.d/snap.lxd.lxc" \
            /var/lib/snapd/hostfs/etc/bash_completion.d/lxc || true
    fi
fi

# FIXME: Setup the "lxd" group
if [ "${daemon_group}" = "lxd" ] && ! getent group lxd >/dev/null 2>&1; then
    echo "==> Creating \"lxd\" group"
    if grep -q "^group.*extrausers" /etc/nsswitch.conf; then
        chroot /var/lib/snapd/hostfs/ groupadd --system --extrausers lxd || true
    else
        chroot /var/lib/snapd/hostfs/ groupadd --system lxd || true
    fi
fi

# Setup for LVM
echo "==> Setting up LVM configuration"
mkdir -p /etc/lvm/
sed \
    -e "s#obtain_device_list_from_udev = 1#obtain_device_list_from_udev = 0#g" \
    -e "s#cache_file_prefix = \"\"#cache_file_prefix = \"lxd\"#g" \
    -e "s#udev_sync = 1#udev_sync = 0#g" \
    -e "s#udev_rules = 1#udev_rules = 0#g" \
    -e "s#use_lvmetad = 1#use_lvmetad = 0#g" \
    -e "s#monitoring = 1#monitoring = 0#g" \
    -e "s%# executable = \"/sbin/dmeventd\"%executable = \"${SNAP}/bin/dmeventd\"%g" \
    -e "/# .*_executable =/s/# //g" \
    -e "s#/usr/sbin/#${SNAP}/bin/#g" \
    "${SNAP}/etc/lvm/lvm.conf" > /etc/lvm/lvm.conf

# Escape resource limits
echo "==> Escaping the systemd cgroups"
for ctr in /sys/fs/cgroup/*; do
    [ -e "${ctr}/cgroup.procs" ] || continue
    echo "$$" > "${ctr}/cgroup.procs"
done

## prlimits
echo "==> Escaping the systemd process resource limits"
prlimit -p $$ --nofile=1048576:1048576 || true
prlimit -p $$ --nproc=unlimited:unlimited || true

# Handle sysctls
if [ -e /proc/sys/fs/inotify/max_user_instances ]; then
    if [ "$(cat /proc/sys/fs/inotify/max_user_instances)" -lt "1024" ]; then
        echo "==> Increasing the number of inotify user instances"
        echo 1024 > /proc/sys/fs/inotify/max_user_instances || true
    fi
fi

if [ -e /proc/sys/kernel/unprivileged_userns_clone ]; then
    echo "==> Enabling unprivileged containers kernel support"
    echo 1 > /proc/sys/kernel/unprivileged_userns_clone || true
fi

# LXC
## Host specific overrides
mkdir -p "${SNAP_COMMON}/lxc"
touch "${SNAP_COMMON}/lxc/local.conf"
if [ -d /sys/kernel/security/apparmor ] && ! grep -q "\-Ubuntu" /proc/version; then
    echo "==> Detected kernel with partial AppArmor support"
    echo "lxc.aa_allow_incomplete = 1" > "${SNAP_COMMON}/lxc/local.conf"
else
    true > "${SNAP_COMMON}/lxc/local.conf"
fi

# Open vSwitch
ln -s /var/lib/snapd/hostfs/run/openvswitch /run/openvswitch

# LXCFS
if [ -e "${SNAP_COMMON}/var/lib/lxcfs/cgroup" ]; then
    echo "=> Re-using existing LXCFS"
    kill -USR1 "$(cat "${SNAP_COMMON}/lxcfs.pid")" || true
else
    ## Undo any existing mount
    umount -l "${SNAP_COMMON}/var/lib/lxcfs" >/dev/null 2>&1 || true
    fusermount -u "${SNAP_COMMON}/var/lib/lxcfs" >/dev/null 2>&1 || true

    ## Create the mount point
    mkdir -p "${SNAP_COMMON}/var/lib/lxcfs"

    ## Cleanup any leftover
    rm -f "${SNAP_COMMON}/lxcfs.pid"

    ## Start lxcfs
    echo "=> Starting LXCFS"
    ( lxcfs "${SNAP_COMMON}/var/lib/lxcfs" -p "${SNAP_COMMON}/lxcfs.pid" & )
fi

# LXD bridge (for LXD 2.0.x)
if [ -x "${SNAP}/bin/lxd-bridge" ]; then
    echo "=> Starting lxd-bridge"
    mkdir -p "${SNAP_COMMON}/lxd-bridge/run" "${SNAP_COMMON}/lxd-bridge/lib"
    lxd-bridge start || true
fi

# LXD
## Create the main directory
if [ ! -d "${SNAP_COMMON}/lxd" ]; then
    mkdir -p "${SNAP_COMMON}/lxd"
    chmod 0755 "${SNAP_COMMON}/lxd"
fi

if [ ! -d "${SNAP_COMMON}/lxd/logs" ]; then
    mkdir -p "${SNAP_COMMON}/lxd/logs"
    chmod 0700 "${SNAP_COMMON}/lxd/logs"
fi

## Start lxd
echo "=> Starting LXD"

LXD="${SNAP_CURRENT}/bin/lxd"
if [ -x "${SNAP_COMMON}/lxd.debug" ]; then
    LXD="${SNAP_COMMON}/lxd.debug"
    echo "==> WARNING: Using a custom debug LXD binary!"
fi

CMD="${LXD} --logfile ${SNAP_COMMON}/lxd/logs/lxd.log"

if getent group "${daemon_group}" >/dev/null 2>&1; then
    CMD="${CMD} --group ${daemon_group}"
else
    echo "==> No \"${daemon_group}\" group found, only root will be able to use LXD."
fi

if [ "${daemon_debug}" = "true" ]; then
    CMD="${CMD} --debug"
fi

${CMD} &

## Wait for it to be ready
PID=$!
echo $PID > "${SNAP_COMMON}/lxd.pid"
"${LXD}" waitready --timeout=600

## Put database in versioned path
if [ ! -L "${SNAP_COMMON}/lxd/lxd.db" ]; then
    mkdir -p "${SNAP_DATA}/lxd/"
    mv "${SNAP_COMMON}/lxd/lxd.db" "${SNAP_DATA}/lxd/lxd.db"
    ln -s "../../current/lxd/lxd.db" "${SNAP_COMMON}/lxd/lxd.db"
fi

## Wait for the daemon to die
echo "=> LXD is ready"
wait $PID
